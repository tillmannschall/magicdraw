<?xml version="1.0" encoding="UTF-8"?><magicdraw><comment classType="Comment" humanType="Comment" icon="index_files/icon_comment_841774062.jpg" id="_10_5_622020d_1132928316401_536158_10714" refElementId="_10_5_622020d_1132928316401_536158_10714"><annotatedElement humanName="Annotated Element" mode="s,e"><interface classType="Interface" humanType="Interface" icon="index_files/icon_interface_1046467249.jpg" name="TransactionalWriter" refElementId="_10_5_622020d_1132928316401_474803_10712" refid="_10_5_622020d_1132928316401_474803_10712"/></annotatedElement><body humanName="Body" mode="s,e">A specialized interface that facilitates an extension of the standard
&lt;code&gt;SyncProvider&lt;/code&gt; abstract class so that it has finer grained
transaction control.
&lt;p&gt;
If one or more disconnected &lt;code&gt;RowSet&lt;/code&gt; objects are particating
in a global transaction, they may wish to coordinate their synchronization
commits to preserve data integrity and reduce the number of
sychronization exceptions. If this is the case, an application should set
the &lt;code&gt;CachedRowSet&lt;/code&gt; constant &lt;code&gt;COMMIT_ON_ACCEPT_CHANGES&lt;/code&gt;
to &lt;code&gt;false&lt;/code&gt; and use the &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;rollback&lt;/code&gt;
methods defined in this interface to manage transaction boundaries.
</body><documentation humanName="Documentation"/><owner classType="Interface" humanName="Owner" humanType="Interface" icon="index_files/icon_interface_1046467249.jpg" mode="s,e" name="TransactionalWriter" refElementId="_10_5_622020d_1132928316401_474803_10712" refid="_10_5_622020d_1132928316401_474803_10712"/><owningElement classType="Interface" humanName="Owning Element" humanType="Interface" icon="index_files/icon_interface_1046467249.jpg" name="TransactionalWriter" refElementId="_10_5_622020d_1132928316401_474803_10712" refid="_10_5_622020d_1132928316401_474803_10712"/><TO_DO humanName="To Do" mode="s,e"/></comment></magicdraw>