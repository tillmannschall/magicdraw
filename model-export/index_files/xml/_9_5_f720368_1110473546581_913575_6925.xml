<?xml version="1.0" encoding="UTF-8"?><magicdraw><class classType="Class" humanType="Class" icon="index_files/icon_class_1555793073.jpg" id="_9_5_f720368_1110473546581_913575_6925"><clientDependency humanName="Client Dependency"><interfacerealization classType="InterfaceRealization" humanType="Interface Realization" icon="index_files/icon_interfacerealization_425275537.jpg" isRelationship="true" name="Interface Realization[JDK 5.0 Classes::java::awt::AlphaComposite -&gt; JDK 5.0 Classes::java::awt::Composite]" refid="_10_5_622020d_1132928321298_730061_13131"/></clientDependency><documentation humanName="Documentation" mode="standard">The &lt;code&gt;AlphaComposite&lt;/code&gt; class implements basic alpha
compositing rules for combining source and destination colors
to achieve blending and transparency effects with graphics and
images.
The specific rules implemented by this class are the basic set
of 12 rules described in
T. Porter and T. Duff, "Compositing Digital Images", SIGGRAPH 84,
253-259.
The rest of this documentation assumes some familiarity with the
definitions and concepts outlined in that paper.

&lt;p&gt;
This class extends the standard equations defined by Porter and
Duff to include one additional factor.
An instance of the &lt;code&gt;AlphaComposite&lt;/code&gt; class can contain
an alpha value that is used to modify the opacity or coverage of
every source pixel before it is used in the blending equations.

&lt;p&gt;
It is important to note that the equations defined by the Porter
and Duff paper are all defined to operate on color components
that are premultiplied by their corresponding alpha components.
Since the &lt;code&gt;ColorModel&lt;/code&gt; and &lt;code&gt;Raster&lt;/code&gt; classes
allow the storage of pixel data in either premultiplied or
non-premultiplied form, all input data must be normalized into
premultiplied form before applying the equations and all results
might need to be adjusted back to the form required by the destination
before the pixel values are stored.

&lt;p&gt;
Also note that this class defines only the equations
for combining color and alpha values in a purely mathematical
sense. The accurate application of its equations depends
on the way the data is retrieved from its sources and stored
in its destinations.
See &lt;a href="#caveats"&gt;Implementation Caveats&lt;/a&gt;
for further information.

&lt;p&gt;
The following factors are used in the description of the blending
equation in the Porter and Duff paper:

&lt;blockquote&gt;
&lt;table summary="layout"&gt;
&lt;tr&gt;&lt;th align=left&gt;Factor&amp;nbsp;&amp;nbsp;&lt;th align=left&gt;Definition
&lt;tr&gt;&lt;td&gt;&lt;em&gt;A&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;&lt;td&gt;the alpha component of the source pixel
&lt;tr&gt;&lt;td&gt;&lt;em&gt;C&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;&lt;td&gt;a color component of the source pixel in premultiplied form
&lt;tr&gt;&lt;td&gt;&lt;em&gt;A&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt;&lt;td&gt;the alpha component of the destination pixel
&lt;tr&gt;&lt;td&gt;&lt;em&gt;C&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt;&lt;td&gt;a color component of the destination pixel in premultiplied form
&lt;tr&gt;&lt;td&gt;&lt;em&gt;F&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;&lt;td&gt;the fraction of the source pixel that contributes to the output
&lt;tr&gt;&lt;td&gt;&lt;em&gt;F&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt;&lt;td&gt;the fraction of the destination pixel that contributes
to the output
&lt;tr&gt;&lt;td&gt;&lt;em&gt;A&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt;&lt;td&gt;the alpha component of the result
&lt;tr&gt;&lt;td&gt;&lt;em&gt;C&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt;&lt;td&gt;a color component of the result in premultiplied form
&lt;/table&gt;
&lt;/blockquote&gt;

&lt;p&gt;
Using these factors, Porter and Duff define 12 ways of choosing
the blending factors &lt;em&gt;F&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; and &lt;em&gt;F&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt; to
produce each of 12 desirable visual effects.
The equations for determining &lt;em&gt;F&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; and &lt;em&gt;F&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt;
are given in the descriptions of the 12 static fields
that specify visual effects.
For example,
the description for
&lt;a href="#SRC_OVER"&gt;&lt;code&gt;SRC_OVER&lt;/code&gt;&lt;/a&gt;
specifies that &lt;em&gt;F&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; = 1 and &lt;em&gt;F&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt; = (1-&lt;em&gt;A&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;).
Once a set of equations for determining the blending factors is
known they can then be applied to each pixel to produce a result
using the following set of equations:

&lt;pre&gt;
&lt;em&gt;F&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;f&lt;/em&gt;(&lt;em&gt;A&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt;)
&lt;em&gt;F&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;f&lt;/em&gt;(&lt;em&gt;A&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;)
&lt;em&gt;A&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;A&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;*&lt;em&gt;F&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; + &lt;em&gt;A&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt;*&lt;em&gt;F&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt;
&lt;em&gt;C&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;C&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;*&lt;em&gt;F&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; + &lt;em&gt;C&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt;*&lt;em&gt;F&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt;&lt;/pre&gt;

&lt;p&gt;
The following factors will be used to discuss our extensions to
the blending equation in the Porter and Duff paper:

&lt;blockquote&gt;
&lt;table summary="layout"&gt;
&lt;tr&gt;&lt;th align=left&gt;Factor&amp;nbsp;&amp;nbsp;&lt;th align=left&gt;Definition
&lt;tr&gt;&lt;td&gt;&lt;em&gt;C&lt;sub&gt;sr&lt;/sub&gt;&lt;/em&gt; &lt;td&gt;one of the raw color components of the source pixel
&lt;tr&gt;&lt;td&gt;&lt;em&gt;C&lt;sub&gt;dr&lt;/sub&gt;&lt;/em&gt; &lt;td&gt;one of the raw color components of the destination pixel
&lt;tr&gt;&lt;td&gt;&lt;em&gt;A&lt;sub&gt;ac&lt;/sub&gt;&lt;/em&gt;  &lt;td&gt;the "extra" alpha component from the AlphaComposite instance
&lt;tr&gt;&lt;td&gt;&lt;em&gt;A&lt;sub&gt;sr&lt;/sub&gt;&lt;/em&gt; &lt;td&gt;the raw alpha component of the source pixel
&lt;tr&gt;&lt;td&gt;&lt;em&gt;A&lt;sub&gt;dr&lt;/sub&gt;&lt;/em&gt;&lt;td&gt;the raw alpha component of the destination pixel
&lt;tr&gt;&lt;td&gt;&lt;em&gt;A&lt;sub&gt;df&lt;/sub&gt;&lt;/em&gt; &lt;td&gt;the final alpha component stored in the destination
&lt;tr&gt;&lt;td&gt;&lt;em&gt;C&lt;sub&gt;df&lt;/sub&gt;&lt;/em&gt; &lt;td&gt;the final raw color component stored in the destination
&lt;/table&gt;
&lt;/blockquote&gt;

&lt;h3&gt;Preparing Inputs&lt;/h3&gt;

&lt;p&gt;
The &lt;code&gt;AlphaComposite&lt;/code&gt; class defines an additional alpha
value that is applied to the source alpha.
This value is applied as if an implicit SRC_IN rule were first
applied to the source pixel against a pixel with the indicated
alpha by multiplying both the raw source alpha and the raw
source colors by the alpha in the &lt;code&gt;AlphaComposite&lt;/code&gt;.
This leads to the following equation for producing the alpha
used in the Porter and Duff blending equation:

&lt;pre&gt;
&lt;em&gt;A&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;A&lt;sub&gt;sr&lt;/sub&gt;&lt;/em&gt; * &lt;em&gt;A&lt;sub&gt;ac&lt;/sub&gt;&lt;/em&gt; &lt;/pre&gt;

All of the raw source color components need to be multiplied
by the alpha in the &lt;code&gt;AlphaComposite&lt;/code&gt; instance.
Additionally, if the source was not in premultiplied form
then the color components also need to be multiplied by the
source alpha.
Thus, the equation for producing the source color components
for the Porter and Duff equation depends on whether the source
pixels are premultiplied or not:

&lt;pre&gt;
&lt;em&gt;C&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;C&lt;sub&gt;sr&lt;/sub&gt;&lt;/em&gt; * &lt;em&gt;A&lt;sub&gt;sr&lt;/sub&gt;&lt;/em&gt; * &lt;em&gt;A&lt;sub&gt;ac&lt;/sub&gt;&lt;/em&gt;     (if source is not premultiplied)
&lt;em&gt;C&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;C&lt;sub&gt;sr&lt;/sub&gt;&lt;/em&gt; * &lt;em&gt;A&lt;sub&gt;ac&lt;/sub&gt;&lt;/em&gt;           (if source is premultiplied) &lt;/pre&gt;

No adjustment needs to be made to the destination alpha:

&lt;pre&gt;
&lt;em&gt;A&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;A&lt;sub&gt;dr&lt;/sub&gt;&lt;/em&gt; &lt;/pre&gt;

&lt;p&gt;
The destination color components need to be adjusted only if
they are not in premultiplied form:

&lt;pre&gt;
&lt;em&gt;C&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;C&lt;sub&gt;dr&lt;/sub&gt;&lt;/em&gt; * &lt;em&gt;A&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt;    (if destination is not premultiplied)
&lt;em&gt;C&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;C&lt;sub&gt;dr&lt;/sub&gt;&lt;/em&gt;         (if destination is premultiplied) &lt;/pre&gt;

&lt;h3&gt;Applying the Blending Equation&lt;/h3&gt;

&lt;p&gt;
The adjusted &lt;em&gt;A&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;, &lt;em&gt;A&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt;,
&lt;em&gt;C&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;, and &lt;em&gt;C&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt; are used in the standard
Porter and Duff equations to calculate the blending factors
&lt;em&gt;F&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; and &lt;em&gt;F&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt; and then the resulting
premultiplied components &lt;em&gt;A&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt; and &lt;em&gt;C&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt;.

&lt;p&gt;
&lt;h3&gt;Preparing Results&lt;/h3&gt;

&lt;p&gt;
The results only need to be adjusted if they are to be stored
back into a destination buffer that holds data that is not
premultiplied, using the following equations:

&lt;pre&gt;
&lt;em&gt;A&lt;sub&gt;df&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;A&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt;
&lt;em&gt;C&lt;sub&gt;df&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;C&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt;                 (if dest is premultiplied)
&lt;em&gt;C&lt;sub&gt;df&lt;/sub&gt;&lt;/em&gt; = &lt;em&gt;C&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt; / &lt;em&gt;A&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt;            (if dest is not premultiplied) &lt;/pre&gt;

Note that since the division is undefined if the resulting alpha
is zero, the division in that case is omitted to avoid the "divide
by zero" and the color components are left as
all zeros.

&lt;p&gt;
&lt;h3&gt;Performance Considerations&lt;/h3&gt;

&lt;p&gt;
For performance reasons, it is preferrable that
&lt;code&gt;Raster&lt;/code&gt; objects passed to the &lt;code&gt;compose&lt;/code&gt;
method of a {@link CompositeContext} object created by the
&lt;code&gt;AlphaComposite&lt;/code&gt; class have premultiplied data.
If either the source &lt;code&gt;Raster&lt;/code&gt;
or the destination &lt;code&gt;Raster&lt;/code&gt;
is not premultiplied, however,
appropriate conversions are performed before and after the compositing
operation.

&lt;h3&gt;&lt;a name="caveats"&gt;Implementation Caveats&lt;/a&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;
Many sources, such as some of the opaque image types listed
in the &lt;code&gt;BufferedImage&lt;/code&gt; class, do not store alpha values
for their pixels.  Such sources supply an alpha of 1.0 for
all of their pixels.

&lt;p&gt;
&lt;li&gt;
Many destinations also have no place to store the alpha values
that result from the blending calculations performed by this class.
Such destinations thus implicitly discard the resulting
alpha values that this class produces.
It is recommended that such destinations should treat their stored
color values as non-premultiplied and divide the resulting color
values by the resulting alpha value before storing the color
values and discarding the alpha value.

&lt;p&gt;
&lt;li&gt;
The accuracy of the results depends on the manner in which pixels
are stored in the destination.
An image format that provides at least 8 bits of storage per color
and alpha component is at least adequate for use as a destination
for a sequence of a few to a dozen compositing operations.
An image format with fewer than 8 bits of storage per component
is of limited use for just one or two compositing operations
before the rounding errors dominate the results.
An image format
that does not separately store
color components is not a
good candidate for any type of translucent blending.
For example, &lt;code&gt;BufferedImage.TYPE_BYTE_INDEXED&lt;/code&gt;
should not be used as a destination for a blending operation
because every operation
can introduce large errors, due to
the need to choose a pixel from a limited palette to match the
results of the blending equations.

&lt;p&gt;
&lt;li&gt;
Nearly all formats store pixels as discrete integers rather than
the floating point values used in the reference equations above.
The implementation can either scale the integer pixel
values into floating point values in the range 0.0 to 1.0 or
use slightly modified versions of the equations
that operate entirely in the integer domain and yet produce
analogous results to the reference equations.

&lt;p&gt;
Typically the integer values are related to the floating point
values in such a way that the integer 0 is equated
to the floating point value 0.0 and the integer
2^&lt;em&gt;n&lt;/em&gt;-1 (where &lt;em&gt;n&lt;/em&gt; is the number of bits
in the representation) is equated to 1.0.
For 8-bit representations, this means that 0x00
represents 0.0 and 0xff represents
1.0.

&lt;p&gt;
&lt;li&gt;
The internal implementation can approximate some of the equations
and it can also eliminate some steps to avoid unnecessary operations.
For example, consider a discrete integer image with non-premultiplied
alpha values that uses 8 bits per component for storage.
The stored values for a
nearly transparent darkened red might be:

&lt;pre&gt;
(A, R, G, B) = (0x01, 0xb0, 0x00, 0x00)&lt;/pre&gt;

&lt;p&gt;
If integer math were being used and this value were being
composited in
&lt;a href="#SRC"&gt;&lt;code&gt;SRC&lt;/code&gt;&lt;/a&gt;
mode with no extra alpha, then the math would
indicate that the results were (in integer format):

&lt;pre&gt;
(A, R, G, B) = (0x01, 0x01, 0x00, 0x00)&lt;/pre&gt;

&lt;p&gt;
Note that the intermediate values, which are always in premultiplied
form, would only allow the integer red component to be either 0x00
or 0x01.  When we try to store this result back into a destination
that is not premultiplied, dividing out the alpha will give us
very few choices for the non-premultiplied red value.
In this case an implementation that performs the math in integer
space without shortcuts is likely to end up with the final pixel
values of:

&lt;pre&gt;
(A, R, G, B) = (0x01, 0xff, 0x00, 0x00)&lt;/pre&gt;

&lt;p&gt;
(Note that 0x01 divided by 0x01 gives you 1.0, which is equivalent
to the value 0xff in an 8-bit storage format.)

&lt;p&gt;
Alternately, an implementation that uses floating point math
might produce more accurate results and end up returning to the
original pixel value with little, if any, roundoff error.
Or, an implementation using integer math might decide that since
the equations boil down to a virtual NOP on the color values
if performed in a floating point space, it can transfer the
pixel untouched to the destination and avoid all the math entirely.

&lt;p&gt;
These implementations all attempt to honor the
same equations, but use different tradeoffs of integer and
floating point math and reduced or full equations.
To account for such differences, it is probably best to
expect only that the premultiplied form of the results to
match between implementations and image formats.  In this
case both answers, expressed in premultiplied form would
equate to:

&lt;pre&gt;
(A, R, G, B) = (0x01, 0x01, 0x00, 0x00)&lt;/pre&gt;

&lt;p&gt;
and thus they would all match.

&lt;p&gt;
&lt;li&gt;
Because of the technique of simplifying the equations for
calculation efficiency, some implementations might perform
differently when encountering result alpha values of 0.0
on a non-premultiplied destination.
Note that the simplification of removing the divide by alpha
in the case of the SRC rule is technically not valid if the
denominator (alpha) is 0.
But, since the results should only be expected to be accurate
when viewed in premultiplied form, a resulting alpha of 0
essentially renders the resulting color components irrelevant
and so exact behavior in this case should not be expected.
&lt;/ul&gt;
@see Composite
@see CompositeContext
@version 10 Feb 1997
</documentation><interfaceRealization humanName="Interface Realization"><interfacerealization classType="InterfaceRealization" humanType="Interface Realization" icon="index_files/icon_interfacerealization_425275537.jpg" isRelationship="true" name="Interface Realization[JDK 5.0 Classes::java::awt::AlphaComposite -&gt; JDK 5.0 Classes::java::awt::Composite]" refid="_10_5_622020d_1132928321298_730061_13131"/></interfaceRealization><isAbstract humanName="Is Abstract" mode="s,e">false</isAbstract><isActive humanName="Is Active" mode="s,e">false</isActive><isFinalSpecialization humanName="Is Final Specialization" mode="e">true</isFinalSpecialization><isLeaf humanName="Is Leaf" mode="e">true</isLeaf><name humanName="Name" mode="s,e">AlphaComposite</name><namespace classType="Package" humanName="Namespace" humanType="Package" icon="index_files/icon_package_2000410491.jpg" name="awt" refid="_9_5_f720368_1110473547268_701783_16331"/><ownedComment humanName="Owned Comment"><comment classType="Comment" humanType="Comment" icon="index_files/icon_comment_2051026490.jpg" refid="_10_5_622020d_1132928306306_194234_4096"/></ownedComment><ownedElement humanName="Owned Element"><comment classType="Comment" humanType="Comment" icon="index_files/icon_comment_2051026490.jpg" refid="_10_5_622020d_1132928306306_194234_4096"/><interfacerealization classType="InterfaceRealization" humanType="Interface Realization" icon="index_files/icon_interfacerealization_425275537.jpg" isRelationship="true" name="Interface Realization[JDK 5.0 Classes::java::awt::AlphaComposite -&gt; JDK 5.0 Classes::java::awt::Composite]" refid="_10_5_622020d_1132928321298_730061_13131"/></ownedElement><owner classType="Package" humanName="Owner" humanType="Package" icon="index_files/icon_package_2000410491.jpg" mode="s,e" name="awt" refid="_9_5_f720368_1110473547268_701783_16331"/><owningPackage classType="Package" humanName="Owning Package" humanType="Package" icon="index_files/icon_package_2000410491.jpg" name="awt" refid="_9_5_f720368_1110473547268_701783_16331"/><package classType="Package" humanName="Package" humanType="Package" icon="index_files/icon_package_2000410491.jpg" name="awt" refid="_9_5_f720368_1110473547268_701783_16331"/><qualifiedName humanName="Qualified Name" mode="e">JDK 5.0 Classes::java::awt::AlphaComposite</qualifiedName><realizedInterfaces humanName="Realized Interface" mode="s,e"><interface classType="Interface" humanType="Interface" icon="index_files/icon_interface_118881143.jpg" name="Composite" refid="_9_5_f720368_1110473546581_157749_6969"/></realizedInterfaces><TO_DO humanName="To Do" mode="s,e"/><visibility humanName="Visibility" mode="e">public</visibility></class></magicdraw>