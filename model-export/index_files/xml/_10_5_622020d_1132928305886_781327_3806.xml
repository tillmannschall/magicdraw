<?xml version="1.0" encoding="UTF-8"?><magicdraw><comment classType="Comment" humanType="Comment" icon="index_files/icon_comment_2051026490.jpg" id="_10_5_622020d_1132928305886_781327_3806"><annotatedElement humanName="Annotated Element" mode="s,e"><class classType="Class" humanType="Class" icon="index_files/icon_class_1555793073.jpg" name="TextLayout" refid="_9_5_f720368_1110473546565_837216_6655"/></annotatedElement><body humanName="Body" mode="s,e">&lt;code&gt;TextLayout&lt;/code&gt; is an immutable graphical representation of styled
character data.
&lt;p&gt;
It provides the following capabilities:
&lt;ul&gt;
&lt;li&gt;implicit bidirectional analysis and reordering,
&lt;li&gt;cursor positioning and movement, including split cursors for
mixed directional text,
&lt;li&gt;highlighting, including both logical and visual highlighting
for mixed directional text,
&lt;li&gt;multiple baselines (roman, hanging, and centered),
&lt;li&gt;hit testing,
&lt;li&gt;justification,
&lt;li&gt;default font substitution,
&lt;li&gt;metric information such as ascent, descent, and advance, and
&lt;li&gt;rendering
&lt;/ul&gt;
&lt;p&gt;
A &lt;code&gt;TextLayout&lt;/code&gt; object can be rendered using
its &lt;code&gt;draw&lt;/code&gt; method.
&lt;p&gt;
&lt;code&gt;TextLayout&lt;/code&gt; can be constructed either directly or through
the use of a {@link LineBreakMeasurer}.  When constructed directly, the
source text represents a single paragraph.  &lt;code&gt;LineBreakMeasurer&lt;/code&gt;
allows styled text to be broken into lines that fit within a particular
width.  See the &lt;code&gt;LineBreakMeasurer&lt;/code&gt; documentation for more
information.
&lt;p&gt;
&lt;code&gt;TextLayout&lt;/code&gt; construction logically proceeds as follows:
&lt;ul&gt;
&lt;li&gt;paragraph attributes are extracted and examined,
&lt;li&gt;text is analyzed for bidirectional reordering, and reordering
information is computed if needed,
&lt;li&gt;text is segmented into style runs
&lt;li&gt;fonts are chosen for style runs, first by using a font if the
attribute {@link TextAttribute#FONT} is present, otherwise by computing
a default font using the attributes that have been defined
&lt;li&gt;if text is on multiple baselines, the runs or subruns are further
broken into subruns sharing a common baseline,
&lt;li&gt;glyphvectors are generated for each run using the chosen font,
&lt;li&gt;final bidirectional reordering is performed on the glyphvectors
&lt;/ul&gt;
&lt;p&gt;
All graphical information returned from a &lt;code&gt;TextLayout&lt;/code&gt;
object's methods is relative to the origin of the
&lt;code&gt;TextLayout&lt;/code&gt;, which is the intersection of the
&lt;code&gt;TextLayout&lt;/code&gt; object's baseline with its left edge.  Also,
coordinates passed into a &lt;code&gt;TextLayout&lt;/code&gt; object's methods
are assumed to be relative to the &lt;code&gt;TextLayout&lt;/code&gt; object's
origin.  Clients usually need to translate between a
&lt;code&gt;TextLayout&lt;/code&gt; object's coordinate system and the coordinate
system in another object (such as a
{@link java.awt.Graphics Graphics} object).
&lt;p&gt;
&lt;code&gt;TextLayout&lt;/code&gt; objects are constructed from styled text,
but they do not retain a reference to their source text.  Thus,
changes in the text previously used to generate a &lt;code&gt;TextLayout&lt;/code&gt;
do not affect the &lt;code&gt;TextLayout&lt;/code&gt;.
&lt;p&gt;
Three methods on a &lt;code&gt;TextLayout&lt;/code&gt; object
(&lt;code&gt;getNextRightHit&lt;/code&gt;, &lt;code&gt;getNextLeftHit&lt;/code&gt;, and
&lt;code&gt;hitTestChar&lt;/code&gt;) return instances of {@link TextHitInfo}.
The offsets contained in these &lt;code&gt;TextHitInfo&lt;/code&gt; objects
are relative to the start of the &lt;code&gt;TextLayout&lt;/code&gt;, &lt;b&gt;not&lt;/b&gt;
to the text used to create the &lt;code&gt;TextLayout&lt;/code&gt;.  Similarly,
&lt;code&gt;TextLayout&lt;/code&gt; methods that accept &lt;code&gt;TextHitInfo&lt;/code&gt;
instances as parameters expect the &lt;code&gt;TextHitInfo&lt;/code&gt; object's
offsets to be relative to the &lt;code&gt;TextLayout&lt;/code&gt;, not to any
underlying text storage model.
&lt;p&gt;
&lt;strong&gt;Examples&lt;/strong&gt;:&lt;p&gt;
Constructing and drawing a &lt;code&gt;TextLayout&lt;/code&gt; and its bounding
rectangle:
&lt;blockquote&gt;&lt;pre&gt;
Graphics2D g = ...;
Point2D loc = ...;
Font font = Font.getFont("Helvetica-bold-italic");
FontRenderContext frc = g.getFontRenderContext();
TextLayout layout = new TextLayout("This is a string", font, frc);
layout.draw(g, (float)loc.getX(), (float)loc.getY());

Rectangle2D bounds = layout.getBounds();
bounds.setRect(bounds.getX()+loc.getX(),
bounds.getY()+loc.getY(),
bounds.getWidth(),
bounds.getHeight());
g.draw(bounds);
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;
Hit-testing a &lt;code&gt;TextLayout&lt;/code&gt; (determining which character is at
a particular graphical location):
&lt;blockquote&gt;&lt;pre&gt;
Point2D click = ...;
TextHitInfo hit = layout.hitTestChar(
(float) (click.getX() - loc.getX()),
(float) (click.getY() - loc.getY()));
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;
Responding to a right-arrow key press:
&lt;blockquote&gt;&lt;pre&gt;
int insertionIndex = ...;
TextHitInfo next = layout.getNextRightHit(insertionIndex);
if (next != null) {
translate graphics to origin of layout on screen
g.translate(loc.getX(), loc.getY());
Shape[] carets = layout.getCaretShapes(next.getInsertionIndex());
g.draw(carets[0]);
if (carets[1] != null) {
g.draw(carets[1]);
}
}
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;
Drawing a selection range corresponding to a substring in the source text.
The selected area may not be visually contiguous:
&lt;blockquote&gt;&lt;pre&gt;
selStart, selLimit should be relative to the layout,
not to the source text

int selStart = ..., selLimit = ...;
Color selectionColor = ...;
Shape selection = layout.getLogicalHighlightShape(selStart, selLimit);
selection may consist of disjoint areas
graphics is assumed to be tranlated to origin of layout
g.setColor(selectionColor);
g.fill(selection);
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;
Drawing a visually contiguous selection range.  The selection range may
correspond to more than one substring in the source text.  The ranges of
the corresponding source text substrings can be obtained with
&lt;code&gt;getLogicalRangesForVisualSelection()&lt;/code&gt;:
&lt;blockquote&gt;&lt;pre&gt;
TextHitInfo selStart = ..., selLimit = ...;
Shape selection = layout.getVisualHighlightShape(selStart, selLimit);
g.setColor(selectionColor);
g.fill(selection);
int[] ranges = getLogicalRangesForVisualSelection(selStart, selLimit);
ranges[0], ranges[1] is the first selection range,
ranges[2], ranges[3] is the second selection range, etc.
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;
@see LineBreakMeasurer
@see TextAttribute
@see TextHitInfo
</body><documentation humanName="Documentation"/><owner classType="Class" humanName="Owner" humanType="Class" icon="index_files/icon_class_1555793073.jpg" mode="s,e" name="TextLayout" refid="_9_5_f720368_1110473546565_837216_6655"/><owningElement classType="Class" humanName="Owning Element" humanType="Class" icon="index_files/icon_class_1555793073.jpg" name="TextLayout" refid="_9_5_f720368_1110473546565_837216_6655"/><TO_DO humanName="To Do" mode="s,e"/></comment></magicdraw>